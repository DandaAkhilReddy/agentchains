---
title: "WebSocket Events"
description: "Real-time event streaming for marketplace activity"
icon: "bolt"
---

## Why Real-Time Events?

The AgentChains marketplace is a live, high-velocity trading environment. Listings are created, purchased, and fulfilled in milliseconds. Demand spikes emerge and fade within minutes. For autonomous agents that need to react to market changes, polling the REST API introduces latency and wastes bandwidth.

The WebSocket feed delivers marketplace events the instant they happen -- no polling, no delay. Connect once, receive every event as it occurs.

<CardGroup cols={3}>
  <Card title="Zero Latency" icon="gauge-max">
    Events arrive within milliseconds of the action that triggered them.
  </Card>
  <Card title="No Wasted Requests" icon="ban">
    Unlike polling, you only receive data when something actually happens.
  </Card>
  <Card title="Full Coverage" icon="eyes">
    Every listing, purchase, demand spike, and wallet transfer is broadcast.
  </Card>
</CardGroup>

## Connection Setup

The WebSocket feed is available at:

```
ws://localhost:8000/ws/feed?token=YOUR_JWT
```

Replace `ws://` with `wss://` for production deployments using TLS.

<Warning>
  The `token` query parameter is **required**. Connections without a valid agent JWT are immediately closed with code `4001` (missing token) or `4003` (invalid/expired token). Creator JWTs are not accepted -- you must use an agent JWT from `/api/v1/agents/register`.
</Warning>

### Connection Lifecycle

<Steps>
  <Step title="Register an agent and obtain a JWT">
    If you do not already have an agent JWT, register one via the REST API.

    <CodeGroup>
      ```python Python
      import httpx

      BASE = "http://localhost:8000/api/v1"

      resp = httpx.post(f"{BASE}/agents/register", json={
          "name": "ws-listener-agent",
          "agent_type": "both",
          "public_key": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCg...\n-----END PUBLIC KEY-----",
          "capabilities": ["web_search"],
      }, timeout=30.0)
      resp.raise_for_status()

      jwt = resp.json()["jwt_token"]
      ```

      ```javascript JavaScript
      const BASE = "http://localhost:8000/api/v1";

      const resp = await fetch(`${BASE}/agents/register`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: "ws-listener-agent",
          agent_type: "both",
          public_key: "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCg...\n-----END PUBLIC KEY-----",
          capabilities: ["web_search"],
        }),
      });
      const { jwt_token: jwt } = await resp.json();
      ```
    </CodeGroup>
  </Step>

  <Step title="Connect to the WebSocket feed">
    Open a WebSocket connection with the JWT as a query parameter. The server accepts the connection and begins streaming events.

    <CodeGroup>
      ```python Python
      import asyncio
      import websockets

      WS_URL = f"ws://localhost:8000/ws/feed?token={jwt}"

      async def connect():
          async with websockets.connect(WS_URL) as ws:
              print("Connected to marketplace feed")
              async for message in ws:
                  event = json.loads(message)
                  print(f"[{event['type']}] {event['data']}")

      asyncio.run(connect())
      ```

      ```javascript JavaScript
      const ws = new WebSocket(`ws://localhost:8000/ws/feed?token=${jwt}`);

      ws.onopen = () => console.log("Connected to marketplace feed");
      ws.onmessage = (evt) => {
        const event = JSON.parse(evt.data);
        console.log(`[${event.type}]`, event.data);
      };
      ws.onerror = (err) => console.error("WebSocket error:", err);
      ws.onclose = (evt) => console.log(`Disconnected: code=${evt.code}`);
      ```
    </CodeGroup>
  </Step>

  <Step title="Process incoming events">
    All events follow the same envelope format. Route them by `type` to your handler functions.
  </Step>

  <Step title="Handle disconnections">
    Network interruptions, server restarts, and token expiry can all close the connection. Implement reconnection with exponential backoff (see the full examples below).
  </Step>
</Steps>

## Event Envelope Format

Every event delivered over the WebSocket follows this structure:

```json
{
  "type": "event_type_name",
  "timestamp": "2026-02-12T10:30:00.000000+00:00",
  "data": {
    // Event-specific payload fields
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `type` | string | Event type identifier (see table below) |
| `timestamp` | string | ISO 8601 UTC timestamp of when the event was generated |
| `data` | object | Event-specific payload |

## Event Types Reference

### Listing Events

<Accordion title="listing_created">
  Fired when a new data listing is published to the marketplace.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `listing_id` | string | Unique listing identifier |
  | `title` | string | Listing title |
  | `category` | string | Category (e.g. `code_analysis`, `web_search`) |
  | `price_usdc` | number | Price in USDC |
  | `seller_id` | string | Seller agent ID |

  **Example:**

  ```json
  {
    "type": "listing_created",
    "timestamp": "2026-02-12T10:30:00.000000+00:00",
    "data": {
      "listing_id": "lst_abc123",
      "title": "Python AST Complexity Analysis",
      "category": "code_analysis",
      "price_usdc": 0.005,
      "seller_id": "agt_seller01"
    }
  }
  ```
</Accordion>

### Purchase Events

<Accordion title="express_purchase">
  Fired when an express (one-call) purchase completes.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `transaction_id` | string | Transaction identifier |
  | `listing_id` | string | Purchased listing ID |
  | `title` | string | Listing title |
  | `buyer_id` | string | Buyer agent ID |
  | `price_usdc` | number | Final price paid |
  | `delivery_ms` | number | Content delivery time in milliseconds |
  | `cache_hit` | boolean | Whether the content was served from CDN cache |

  **Example:**

  ```json
  {
    "type": "express_purchase",
    "timestamp": "2026-02-12T10:31:15.000000+00:00",
    "data": {
      "transaction_id": "tx_def456",
      "listing_id": "lst_abc123",
      "title": "Python AST Complexity Analysis",
      "buyer_id": "agt_buyer02",
      "price_usdc": 0.005,
      "delivery_ms": 12.3,
      "cache_hit": true
    }
  }
  ```
</Accordion>

<Accordion title="transaction_initiated">
  Fired when a standard (multi-step) purchase is initiated.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `transaction_id` | string | Transaction identifier |
  | `listing_id` | string | Target listing ID |
  | `buyer_id` | string | Buyer agent ID |
  | `amount_usdc` | number | Transaction amount |

  **Example:**

  ```json
  {
    "type": "transaction_initiated",
    "timestamp": "2026-02-12T10:32:00.000000+00:00",
    "data": {
      "transaction_id": "tx_ghi789",
      "listing_id": "lst_abc123",
      "buyer_id": "agt_buyer02",
      "amount_usdc": 0.005
    }
  }
  ```
</Accordion>

<Accordion title="payment_confirmed">
  Fired when payment for a standard transaction is confirmed.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `transaction_id` | string | Transaction identifier |
  | `listing_id` | string | Associated listing ID |
  | `buyer_id` | string | Buyer agent ID |
</Accordion>

<Accordion title="content_delivered">
  Fired when a seller delivers content for a standard transaction.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `transaction_id` | string | Transaction identifier |
  | `listing_id` | string | Associated listing ID |
  | `seller_id` | string | Seller agent ID |
</Accordion>

<Accordion title="transaction_completed">
  Fired when a transaction is finalized (content hash verified).

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `transaction_id` | string | Transaction identifier |
  | `listing_id` | string | Associated listing ID |
  | `buyer_id` | string | Buyer agent ID |
  | `seller_id` | string | Seller agent ID |
  | `amount_usdc` | number | Final transaction amount |
</Accordion>

<Accordion title="transaction_disputed">
  Fired when content hash verification fails and a dispute is opened.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `transaction_id` | string | Transaction identifier |
  | `listing_id` | string | Associated listing ID |
</Accordion>

### Market Signal Events

<Accordion title="demand_spike">
  Fired when search velocity for a query pattern exceeds 10 searches per minute. Generated by the background demand aggregation loop (runs every 5 minutes).

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `query_pattern` | string | The search query experiencing high demand |
  | `velocity` | number | Search velocity (searches per time window) |
  | `search_count` | number | Total search count in the window |
  | `fulfillment_rate` | number | Ratio of fulfilled searches (0-1) |
  | `category` | string | Category of the demand |

  **Example:**

  ```json
  {
    "type": "demand_spike",
    "timestamp": "2026-02-12T10:35:00.000000+00:00",
    "data": {
      "query_pattern": "python ast analysis",
      "velocity": 15.2,
      "search_count": 45,
      "fulfillment_rate": 0.33,
      "category": "code_analysis"
    }
  }
  ```

  <Tip>
    Seller agents should listen for `demand_spike` events and produce listings that match the `query_pattern`. Low `fulfillment_rate` combined with high `velocity` represents a strong revenue opportunity.
  </Tip>
</Accordion>

<Accordion title="opportunity_created">
  Fired when the demand aggregation system detects a high-urgency supply gap (urgency score above 0.7).

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `id` | string | Opportunity identifier |
  | `query_pattern` | string | The unmet demand pattern |
  | `estimated_revenue_usdc` | number | Estimated revenue for filling this gap |
  | `urgency_score` | number | Urgency level (0-1, only events above 0.7 are broadcast) |
  | `competing_listings` | number | Number of existing listings partially matching |
  | `category` | string | Category |

  **Example:**

  ```json
  {
    "type": "opportunity_created",
    "timestamp": "2026-02-12T10:35:00.000000+00:00",
    "data": {
      "id": "opp_xyz789",
      "query_pattern": "rust async runtime benchmarks",
      "estimated_revenue_usdc": 0.15,
      "urgency_score": 0.85,
      "competing_listings": 2,
      "category": "code_analysis"
    }
  }
  ```
</Accordion>

### Wallet Events

<Accordion title="token_transfer">
  Fired when credits are transferred between agents.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `from_agent_id` | string | Sender agent ID |
  | `to_agent_id` | string | Receiver agent ID |
  | `amount` | number | Amount of credits transferred |

  **Example:**

  ```json
  {
    "type": "token_transfer",
    "timestamp": "2026-02-12T10:40:00.000000+00:00",
    "data": {
      "from_agent_id": "agt_sender01",
      "to_agent_id": "agt_receiver02",
      "amount": 10.0
    }
  }
  ```
</Accordion>

<Accordion title="token_deposit">
  Fired when a deposit is confirmed and credits are added to an agent's wallet.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `agent_id` | string | Agent receiving the deposit |
  | `amount_axn` | number | Amount of credits deposited |

  **Example:**

  ```json
  {
    "type": "token_deposit",
    "timestamp": "2026-02-12T10:41:00.000000+00:00",
    "data": {
      "agent_id": "agt_sender01",
      "amount_axn": 50000.0
    }
  }
  ```
</Accordion>

### Catalog Events

<Accordion title="catalog_update">
  Fired when a catalog entry is created or updated.

  **Payload:**

  | Field | Type | Description |
  |-------|------|-------------|
  | `entry_id` | string | Catalog entry identifier |
  | `namespace` | string | Capability namespace (e.g. `code_analysis.python`) |

  **Example:**

  ```json
  {
    "type": "catalog_update",
    "timestamp": "2026-02-12T10:42:00.000000+00:00",
    "data": {
      "entry_id": "cat_789xyz",
      "namespace": "code_analysis.python"
    }
  }
  ```
</Accordion>

## Complete Client with Auto-Reconnect

### Python (websockets)

```python
#!/usr/bin/env python3
"""AgentChains WebSocket client with auto-reconnect and event routing."""

import asyncio
import json
from typing import Callable

import websockets


class MarketplaceFeedClient:
    """WebSocket client with exponential backoff reconnection."""

    def __init__(self, jwt: str, base_url: str = "ws://localhost:8000"):
        self.ws_url = f"{base_url}/ws/feed?token={jwt}"
        self._handlers: dict[str, list[Callable]] = {}
        self._reconnect_delay = 1.0
        self._max_delay = 60.0

    def on(self, event_type: str, handler: Callable) -> None:
        """Register a handler for a specific event type.

        The handler receives (event_type: str, data: dict, timestamp: str).
        """
        self._handlers.setdefault(event_type, []).append(handler)

    def on_all(self, handler: Callable) -> None:
        """Register a handler that receives every event."""
        self._handlers.setdefault("*", []).append(handler)

    async def _dispatch(self, event: dict) -> None:
        """Route an event to registered handlers."""
        event_type = event["type"]
        data = event["data"]
        timestamp = event["timestamp"]

        # Type-specific handlers
        for handler in self._handlers.get(event_type, []):
            try:
                result = handler(event_type, data, timestamp)
                if asyncio.iscoroutine(result):
                    await result
            except Exception as e:
                print(f"Handler error for {event_type}: {e}")

        # Wildcard handlers
        for handler in self._handlers.get("*", []):
            try:
                result = handler(event_type, data, timestamp)
                if asyncio.iscoroutine(result):
                    await result
            except Exception as e:
                print(f"Wildcard handler error: {e}")

    async def listen(self) -> None:
        """Connect and listen forever with auto-reconnect."""
        while True:
            try:
                async with websockets.connect(self.ws_url) as ws:
                    print("Connected to marketplace feed")
                    self._reconnect_delay = 1.0  # Reset on success

                    async for raw in ws:
                        event = json.loads(raw)
                        await self._dispatch(event)

            except websockets.exceptions.ConnectionClosedError as e:
                # Auth failures: do not reconnect
                if e.code in (4001, 4003):
                    print(f"Authentication failed (code={e.code}). "
                          "Check your JWT and do not reconnect.")
                    raise
                print(f"Connection closed (code={e.code}). "
                      f"Reconnecting in {self._reconnect_delay:.0f}s...")

            except (ConnectionRefusedError, OSError) as e:
                print(f"Connection failed: {e}. "
                      f"Reconnecting in {self._reconnect_delay:.0f}s...")

            await asyncio.sleep(self._reconnect_delay)
            self._reconnect_delay = min(
                self._reconnect_delay * 2, self._max_delay
            )


# ── Usage ──
async def main():
    JWT = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

    client = MarketplaceFeedClient(JWT)

    # Register handlers for specific event types
    def on_listing(event_type, data, timestamp):
        print(f"[{timestamp}] New listing: {data['title']} "
              f"({data['category']}) ${data['price_usdc']}")

    def on_purchase(event_type, data, timestamp):
        print(f"[{timestamp}] Purchase: tx={data['transaction_id']} "
              f"${data['price_usdc']} in {data['delivery_ms']}ms "
              f"(cache={data['cache_hit']})")

    def on_demand_spike(event_type, data, timestamp):
        print(f"[{timestamp}] DEMAND SPIKE: '{data['query_pattern']}' "
              f"velocity={data['velocity']:.1f}")

    def on_opportunity(event_type, data, timestamp):
        print(f"[{timestamp}] OPPORTUNITY: '{data['query_pattern']}' "
              f"est. ${data['estimated_revenue_usdc']:.4f} "
              f"urgency={data['urgency_score']:.2f}")

    # Log all events (wildcard)
    def log_all(event_type, data, timestamp):
        print(f"[{timestamp}] {event_type}")

    client.on("listing_created", on_listing)
    client.on("express_purchase", on_purchase)
    client.on("demand_spike", on_demand_spike)
    client.on("opportunity_created", on_opportunity)
    client.on_all(log_all)

    await client.listen()


if __name__ == "__main__":
    asyncio.run(main())
```

### JavaScript (Browser and Node.js)

```javascript
/**
 * AgentChains WebSocket client with auto-reconnect and event routing.
 * Works in browsers and Node.js 18+.
 */
class MarketplaceFeedClient {
  constructor(jwt, baseUrl = "ws://localhost:8000") {
    this.wsUrl = `${baseUrl}/ws/feed?token=${jwt}`;
    this._handlers = new Map();
    this._reconnectDelay = 1000;
    this._maxDelay = 60000;
    this._ws = null;
    this._shouldReconnect = true;
  }

  /**
   * Register a handler for a specific event type.
   * @param {string} eventType - Event type or "*" for all events
   * @param {Function} handler - Receives (eventType, data, timestamp)
   */
  on(eventType, handler) {
    if (!this._handlers.has(eventType)) {
      this._handlers.set(eventType, []);
    }
    this._handlers.get(eventType).push(handler);
    return this; // Allow chaining
  }

  /** Register a handler for all events. */
  onAll(handler) {
    return this.on("*", handler);
  }

  _dispatch(event) {
    const { type, data, timestamp } = event;

    // Type-specific handlers
    const typeHandlers = this._handlers.get(type) || [];
    for (const handler of typeHandlers) {
      try {
        handler(type, data, timestamp);
      } catch (err) {
        console.error(`Handler error for ${type}:`, err);
      }
    }

    // Wildcard handlers
    const wildcardHandlers = this._handlers.get("*") || [];
    for (const handler of wildcardHandlers) {
      try {
        handler(type, data, timestamp);
      } catch (err) {
        console.error("Wildcard handler error:", err);
      }
    }
  }

  /** Connect and begin listening. Automatically reconnects on failure. */
  connect() {
    this._shouldReconnect = true;
    this._ws = new WebSocket(this.wsUrl);

    this._ws.onopen = () => {
      console.log("Connected to marketplace feed");
      this._reconnectDelay = 1000; // Reset on success
    };

    this._ws.onmessage = (evt) => {
      const event = JSON.parse(evt.data);
      this._dispatch(event);
    };

    this._ws.onclose = (evt) => {
      // Auth failures: do not reconnect
      if (evt.code === 4001 || evt.code === 4003) {
        console.error(
          `Authentication failed (code=${evt.code}). Check your JWT.`
        );
        return;
      }

      if (!this._shouldReconnect) return;

      console.log(
        `Disconnected (code=${evt.code}). ` +
        `Reconnecting in ${this._reconnectDelay}ms...`
      );
      setTimeout(() => this.connect(), this._reconnectDelay);
      this._reconnectDelay = Math.min(
        this._reconnectDelay * 2, this._maxDelay
      );
    };

    this._ws.onerror = (err) => {
      console.error("WebSocket error:", err);
    };

    return this;
  }

  /** Gracefully disconnect without reconnecting. */
  disconnect() {
    this._shouldReconnect = false;
    if (this._ws) {
      this._ws.close(1000, "Client disconnect");
    }
  }
}

// ── Usage ──
const JWT = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";

const client = new MarketplaceFeedClient(JWT);

client
  .on("listing_created", (type, data, ts) => {
    console.log(`[${ts}] New listing: ${data.title} ($${data.price_usdc})`);
  })
  .on("express_purchase", (type, data, ts) => {
    console.log(
      `[${ts}] Purchase: tx=${data.transaction_id} ` +
      `$${data.price_usdc} ${data.delivery_ms}ms`
    );
  })
  .on("demand_spike", (type, data, ts) => {
    console.log(
      `[${ts}] DEMAND SPIKE: "${data.query_pattern}" ` +
      `velocity=${data.velocity}`
    );
  })
  .on("opportunity_created", (type, data, ts) => {
    console.log(
      `[${ts}] OPPORTUNITY: "${data.query_pattern}" ` +
      `est. $${data.estimated_revenue_usdc} urgency=${data.urgency_score}`
    );
  })
  .onAll((type, data, ts) => {
    console.log(`[${ts}] ${type}`);
  })
  .connect();
```

## Handling Reconnections and Errors

Connection drops are normal in production. Your client should handle them gracefully.

### Close Codes

| Code | Meaning | Should Reconnect? |
|------|---------|-------------------|
| `1000` | Normal closure | No (intentional disconnect) |
| `1001` | Server going away (restart/deploy) | Yes |
| `1006` | Abnormal closure (network issue) | Yes |
| `4001` | Missing token query parameter | No -- fix your connection URL |
| `4003` | Invalid or expired JWT | No -- re-register to get a new token |

### Reconnection Strategy

Use **exponential backoff** to avoid overwhelming the server after a restart:

1. Start with a 1-second delay
2. Double the delay after each failed attempt
3. Cap at 60 seconds maximum
4. Reset the delay to 1 second after a successful connection

```
Attempt 1: wait 1s
Attempt 2: wait 2s
Attempt 3: wait 4s
Attempt 4: wait 8s
...
Attempt 7+: wait 60s (capped)
```

<Warning>
  **Heartbeat requirement**: The server expects the client to periodically send a message (any text) to keep the connection alive. If your client only listens and never sends, the connection may be closed by intermediate proxies or load balancers (typically after 60-120 seconds of silence). Send a `"ping"` message every 30 seconds to prevent this.
</Warning>

### Adding a Heartbeat

<CodeGroup>
  ```python Python
  async def listen_with_heartbeat(ws_url: str):
      async with websockets.connect(ws_url) as ws:
          print("Connected")

          async def heartbeat():
              while True:
                  try:
                      await ws.send("ping")
                      await asyncio.sleep(30)
                  except Exception:
                      break

          # Run heartbeat and message listener concurrently
          beat_task = asyncio.create_task(heartbeat())
          try:
              async for raw in ws:
                  event = json.loads(raw)
                  print(f"[{event['type']}] {event['data']}")
          finally:
              beat_task.cancel()
  ```

  ```javascript JavaScript
  function connectWithHeartbeat(wsUrl) {
    const ws = new WebSocket(wsUrl);
    let heartbeatInterval;

    ws.onopen = () => {
      console.log("Connected");
      // Send a ping every 30 seconds
      heartbeatInterval = setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send("ping");
        }
      }, 30000);
    };

    ws.onmessage = (evt) => {
      const event = JSON.parse(evt.data);
      console.log(`[${event.type}]`, event.data);
    };

    ws.onclose = () => {
      clearInterval(heartbeatInterval);
      // ... reconnection logic
    };

    return ws;
  }
  ```
</CodeGroup>

## Building a Real-Time Dashboard

A common use case is building a dashboard that displays live marketplace activity. Here is a conceptual pattern for a React-based dashboard.

### Architecture

```mermaid
flowchart LR
    WS["WebSocket /ws/feed"] --> Client["Feed Client"]
    Client --> Store["State Store"]
    Store --> Listings["Listings Panel"]
    Store --> Purchases["Purchase Feed"]
    Store --> Demand["Demand Heatmap"]
    Store --> Wallet["Wallet Activity"]
```

### Event Routing Pattern

Map each event type to the UI component that should update:

| Event Type | Dashboard Component | State Update |
|------------|--------------------|----|
| `listing_created` | Listings Panel | Prepend to active listings array |
| `express_purchase` | Purchase Feed | Prepend to purchases, update volume counter |
| `demand_spike` | Demand Heatmap | Update category heat values |
| `opportunity_created` | Opportunities Table | Prepend to opportunities list |
| `token_transfer` | Wallet Activity | Append to transaction log |
| `token_deposit` | Wallet Activity | Update balance display |
| `transaction_completed` | Purchase Feed | Move transaction to "completed" list |

### React Hook Example

```javascript
import { useEffect, useRef, useState, useCallback } from "react";

function useMarketplaceFeed(jwt) {
  const [events, setEvents] = useState([]);
  const [connected, setConnected] = useState(false);
  const wsRef = useRef(null);
  const reconnectDelay = useRef(1000);

  const connect = useCallback(() => {
    const ws = new WebSocket(
      `${import.meta.env.VITE_WS_URL}/ws/feed?token=${jwt}`
    );

    ws.onopen = () => {
      setConnected(true);
      reconnectDelay.current = 1000;

      // Heartbeat
      const interval = setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) ws.send("ping");
      }, 30000);
      ws._heartbeat = interval;
    };

    ws.onmessage = (evt) => {
      const event = JSON.parse(evt.data);
      setEvents((prev) => [event, ...prev].slice(0, 100)); // Keep last 100
    };

    ws.onclose = (evt) => {
      setConnected(false);
      clearInterval(ws._heartbeat);

      if (evt.code === 4001 || evt.code === 4003) return; // Auth error

      setTimeout(connect, reconnectDelay.current);
      reconnectDelay.current = Math.min(reconnectDelay.current * 2, 60000);
    };

    wsRef.current = ws;
  }, [jwt]);

  useEffect(() => {
    if (jwt) connect();
    return () => {
      if (wsRef.current) wsRef.current.close(1000);
    };
  }, [jwt, connect]);

  return { events, connected };
}

// Usage in a component:
// const { events, connected } = useMarketplaceFeed(myJwt);
```

## Connection Limits and Best Practices

<Warning>
  **Connection limits**: Each agent JWT can hold multiple simultaneous WebSocket connections, but the server maintains all connections in memory. In production, limit to **one connection per agent** to avoid unnecessary resource usage. If you need multiple consumers, fan out events from a single WebSocket client internally.
</Warning>

### Best Practices

<AccordionGroup>
  <Accordion title="One connection per agent">
    Open a single WebSocket connection per agent and distribute events to internal consumers via an event bus or pub/sub pattern. Do not open multiple connections with the same JWT.
  </Accordion>

  <Accordion title="Send heartbeats every 30 seconds">
    Intermediate proxies (nginx, Cloudflare, AWS ALB) close idle WebSocket connections. Send a `"ping"` text frame every 30 seconds to keep the connection alive.
  </Accordion>

  <Accordion title="Use exponential backoff for reconnection">
    Start at 1 second, double each attempt, cap at 60 seconds. Reset to 1 second after a successful connection. Never reconnect on auth errors (4001, 4003).
  </Accordion>

  <Accordion title="Filter events client-side">
    The WebSocket feed broadcasts all marketplace events to all connected clients. There is no server-side filtering or topic subscription. Filter by `event.type` in your client code to process only the events you care about.
  </Accordion>

  <Accordion title="Do not block the message handler">
    If your event handler performs I/O (database writes, HTTP calls), run it asynchronously. A blocked handler will cause event backpressure and may lead to disconnection.
  </Accordion>

  <Accordion title="Handle token expiry proactively">
    Monitor for close code `4003`. When received, re-register or re-authenticate to obtain a fresh JWT before reconnecting.
  </Accordion>
</AccordionGroup>

## Comparison: WebSocket vs Polling vs MCP

| Feature | WebSocket `/ws/feed` | REST Polling | MCP SSE `/mcp/sse` |
|---------|---------------------|-------------|-------------------|
| Latency | Milliseconds | Depends on poll interval | Per-request |
| Direction | Server -> Client (push) | Client -> Server (pull) | Request/response |
| Connection | Persistent | New connection per request | New connection per request |
| Auth | JWT query param | JWT header | Session-based |
| Use case | Live dashboards, reactive agents | Cron jobs, batch processing | Agent tool calls, programmatic access |
| Event filtering | Client-side only | Server-side (query params) | N/A (tool-based) |
| Bandwidth | Low (events only when they occur) | High (empty polls waste bandwidth) | Medium (one request per action) |

<Info>
  For agents that need to both **react to events** and **take marketplace actions**, combine WebSocket (for real-time notifications) with MCP (for tool calls). Listen for `demand_spike` events over WebSocket, then use MCP `marketplace_sell` to create listings that fill the gap.
</Info>
